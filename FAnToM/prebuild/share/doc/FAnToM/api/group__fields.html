<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FAnToM: Fields, Grids, and Cells</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="FAnToM-logo.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FAnToM
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">scientific visualization and analysis</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Fields, Grids, and Cells</div>  </div>
</div><!--header-->
<div class="contents">

<p>This part of the tutorial shows how to work with tensor fields and grids. It also demonstrates the use of OpenMP to enable parallel computation. If the OpenMP statements confuse you, you can ignore them completely; the code also describes the single-threaded version. The tutorial does not aim to be an exhaustive description of OpenMP's features and API; you can easily find such things on the web.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Fields, Grids, and Cells:</div>
<div class="dyncontent">
<div class="center"><img src="group__fields.png" border="0" usemap="#group____fields" alt=""/></div>
<map name="group____fields" id="group____fields">
<area shape="rect" href="group__commit.html" title="This part of the tutorial shows how add new data to the system." alt="" coords="277,22,431,47"/>
<area shape="rect" title="This part of the tutorial shows how to work with tensor fields and grids. It also demonstrates the us..." alt="" coords="5,15,131,55"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1Cell.html">fantom::Cell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference to a grid cell  <a href="classfantom_1_1Cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1Domain.html">fantom::Domain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discrete domain.  <a href="classfantom_1_1Domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1Grid.html">fantom::Grid&lt; D &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of grids.  <a href="classfantom_1_1Grid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1SpatialFunction.html">fantom::SpatialFunction&lt; D, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1Function.html">fantom::Function&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of data values on a discrete domain.  <a href="classfantom_1_1Function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1FieldEvaluator.html">fantom::FieldEvaluator&lt; D, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluator.  <a href="classfantom_1_1FieldEvaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1Field.html">fantom::Field&lt; D, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An analytical or interpolated tensor field.  <a href="classfantom_1_1Field.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga48dac8c1392e48bc96a602a9fb7c1ee7"><td class="memItemLeft" align="right" valign="top"><a id="ga48dac8c1392e48bc96a602a9fb7c1ee7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fields.html#ga48dac8c1392e48bc96a602a9fb7c1ee7">fantom::All_CellComplex</a> = <a class="el" href="structfantom_1_1TypeList.html">TypeList</a>&lt; <a class="el" href="classfantom_1_1EmbeddedCellComplex.html">EmbeddedCellComplex</a>&lt; 1 &gt;, <a class="el" href="classfantom_1_1EmbeddedCellComplex.html">EmbeddedCellComplex</a>&lt; 2 &gt;, <a class="el" href="classfantom_1_1EmbeddedCellComplex.html">EmbeddedCellComplex</a>&lt; 3 &gt; &gt;</td></tr>
<tr class="memdesc:ga48dac8c1392e48bc96a602a9fb7c1ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple typelist for matching all cell complex types in options. <br /></td></tr>
<tr class="separator:ga48dac8c1392e48bc96a602a9fb7c1ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87df664026b2c8cd90282b53f210ae4f"><td class="memItemLeft" align="right" valign="top"><a id="ga87df664026b2c8cd90282b53f210ae4f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fields.html#ga87df664026b2c8cd90282b53f210ae4f">fantom::CellComplex2_or_3</a> = <a class="el" href="structfantom_1_1TypeList.html">TypeList</a>&lt; <a class="el" href="classfantom_1_1EmbeddedCellComplex.html">EmbeddedCellComplex</a>&lt; 2 &gt;, <a class="el" href="classfantom_1_1EmbeddedCellComplex.html">EmbeddedCellComplex</a>&lt; 3 &gt; &gt;</td></tr>
<tr class="memdesc:ga87df664026b2c8cd90282b53f210ae4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple typelist for matching all 2D and 3D cell complex types in options. <br /></td></tr>
<tr class="separator:ga87df664026b2c8cd90282b53f210ae4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fbad74a9cc0e43e9ed8da8665552043"><td class="memItemLeft" align="right" valign="top"><a id="ga0fbad74a9cc0e43e9ed8da8665552043"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fields.html#ga0fbad74a9cc0e43e9ed8da8665552043">fantom::All_Grid</a> = <a class="el" href="structfantom_1_1TypeList.html">TypeList</a>&lt; <a class="el" href="classfantom_1_1Grid.html">Grid</a>&lt; 1 &gt;, <a class="el" href="classfantom_1_1Grid.html">Grid</a>&lt; 2 &gt;, <a class="el" href="classfantom_1_1Grid.html">Grid</a>&lt; 3 &gt; &gt;</td></tr>
<tr class="memdesc:ga0fbad74a9cc0e43e9ed8da8665552043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple typelist for matching all grid types in options. <br /></td></tr>
<tr class="separator:ga0fbad74a9cc0e43e9ed8da8665552043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga862b7d4c009d7c66876eb68d74ac7d6f"><td class="memItemLeft" align="right" valign="top"><a id="ga862b7d4c009d7c66876eb68d74ac7d6f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fields.html#ga862b7d4c009d7c66876eb68d74ac7d6f">fantom::Grid2_or_3</a> = <a class="el" href="structfantom_1_1TypeList.html">TypeList</a>&lt; <a class="el" href="classfantom_1_1Grid.html">Grid</a>&lt; 2 &gt;, <a class="el" href="classfantom_1_1Grid.html">Grid</a>&lt; 3 &gt; &gt;</td></tr>
<tr class="memdesc:ga862b7d4c009d7c66876eb68d74ac7d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple typelist for matching all 2D and 3D grid types in options. <br /></td></tr>
<tr class="separator:ga862b7d4c009d7c66876eb68d74ac7d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae402e05102a994fd4fcd91b8721c1ad0"><td class="memItemLeft" align="right" valign="top"><a id="gae402e05102a994fd4fcd91b8721c1ad0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fields.html#gae402e05102a994fd4fcd91b8721c1ad0">fantom::All_LineSet</a> = <a class="el" href="structfantom_1_1TypeList.html">TypeList</a>&lt; <a class="el" href="classfantom_1_1LineSet.html">LineSet</a>&lt; 1 &gt;, <a class="el" href="classfantom_1_1LineSet.html">LineSet</a>&lt; 2 &gt;, <a class="el" href="classfantom_1_1LineSet.html">LineSet</a>&lt; 3 &gt; &gt;</td></tr>
<tr class="memdesc:gae402e05102a994fd4fcd91b8721c1ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple typelist for matching all <a class="el" href="classfantom_1_1LineSet.html" title="Collection of lines.">LineSet</a> types in options. <br /></td></tr>
<tr class="separator:gae402e05102a994fd4fcd91b8721c1ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91960f67a1c16b94be91d89426fc1e80"><td class="memItemLeft" align="right" valign="top"><a id="ga91960f67a1c16b94be91d89426fc1e80"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fields.html#ga91960f67a1c16b94be91d89426fc1e80">fantom::LineSet2_or_3</a> = <a class="el" href="structfantom_1_1TypeList.html">TypeList</a>&lt; <a class="el" href="classfantom_1_1LineSet.html">LineSet</a>&lt; 2 &gt;, <a class="el" href="classfantom_1_1LineSet.html">LineSet</a>&lt; 3 &gt; &gt;</td></tr>
<tr class="memdesc:ga91960f67a1c16b94be91d89426fc1e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple typelist for matching all 2D and 3D <a class="el" href="classfantom_1_1LineSet.html" title="Collection of lines.">LineSet</a> types in options. <br /></td></tr>
<tr class="separator:ga91960f67a1c16b94be91d89426fc1e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga887e3c5746dfa21ad1cca832ad4cf6a8"><td class="memItemLeft" align="right" valign="top"><a id="ga887e3c5746dfa21ad1cca832ad4cf6a8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fields.html#ga887e3c5746dfa21ad1cca832ad4cf6a8">fantom::All_PointSet</a> = <a class="el" href="structfantom_1_1TypeList.html">TypeList</a>&lt; <a class="el" href="classfantom_1_1PointSet.html">PointSet</a>&lt; 1 &gt;, <a class="el" href="classfantom_1_1PointSet.html">PointSet</a>&lt; 2 &gt;, <a class="el" href="classfantom_1_1PointSet.html">PointSet</a>&lt; 3 &gt; &gt;</td></tr>
<tr class="memdesc:ga887e3c5746dfa21ad1cca832ad4cf6a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple typelist for matching all <a class="el" href="classfantom_1_1PointSet.html" title="representation of a discrete set of points">PointSet</a> types in options. <br /></td></tr>
<tr class="separator:ga887e3c5746dfa21ad1cca832ad4cf6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga922498345e8b66cff3458e485e640e0f"><td class="memItemLeft" align="right" valign="top"><a id="ga922498345e8b66cff3458e485e640e0f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fields.html#ga922498345e8b66cff3458e485e640e0f">fantom::PointSet2_or_3</a> = <a class="el" href="structfantom_1_1TypeList.html">TypeList</a>&lt; <a class="el" href="classfantom_1_1PointSet.html">PointSet</a>&lt; 2 &gt;, <a class="el" href="classfantom_1_1PointSet.html">PointSet</a>&lt; 3 &gt; &gt;</td></tr>
<tr class="memdesc:ga922498345e8b66cff3458e485e640e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple typelist for matching all 2D and 3D <a class="el" href="classfantom_1_1PointSet.html" title="representation of a discrete set of points">PointSet</a> types in options. <br /></td></tr>
<tr class="separator:ga922498345e8b66cff3458e485e640e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58fcf788861db0087d244d947becaa19"><td class="memItemLeft" align="right" valign="top"><a id="ga58fcf788861db0087d244d947becaa19"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fields.html#ga58fcf788861db0087d244d947becaa19">fantom::ScalarFunction</a> = <a class="el" href="classfantom_1_1Function.html">Function</a>&lt; <a class="el" href="group__math.html#ga01543b9b8f99fee61cdd2a3999096fde">Scalar</a> &gt;</td></tr>
<tr class="memdesc:ga58fcf788861db0087d244d947becaa19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar functions. <br /></td></tr>
<tr class="separator:ga58fcf788861db0087d244d947becaa19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f6e51d404b7a51e5522abbf3f9276b8"><td class="memTemplParams" colspan="2"><a id="ga4f6e51d404b7a51e5522abbf3f9276b8"></a>
template&lt;size_t D&gt; </td></tr>
<tr class="memitem:ga4f6e51d404b7a51e5522abbf3f9276b8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fields.html#ga4f6e51d404b7a51e5522abbf3f9276b8">fantom::VectorFunction</a> = <a class="el" href="classfantom_1_1Function.html">Function</a>&lt; <a class="el" href="classfantom_1_1Tensor.html">Tensor</a>&lt; double, D &gt; &gt;</td></tr>
<tr class="memdesc:ga4f6e51d404b7a51e5522abbf3f9276b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector functions. <br /></td></tr>
<tr class="separator:ga4f6e51d404b7a51e5522abbf3f9276b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf4356613b4f975f95e0d1b0b667c4d7"><td class="memTemplParams" colspan="2"><a id="gadf4356613b4f975f95e0d1b0b667c4d7"></a>
template&lt;size_t D&gt; </td></tr>
<tr class="memitem:gadf4356613b4f975f95e0d1b0b667c4d7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fields.html#gadf4356613b4f975f95e0d1b0b667c4d7">fantom::MatrixFunction</a> = <a class="el" href="classfantom_1_1Function.html">Function</a>&lt; <a class="el" href="classfantom_1_1Tensor.html">Tensor</a>&lt; double, D, D &gt; &gt;</td></tr>
<tr class="memdesc:gadf4356613b4f975f95e0d1b0b667c4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix functions. <br /></td></tr>
<tr class="separator:gadf4356613b4f975f95e0d1b0b667c4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44715ea73b26246ec47ff7f72eca6a68"><td class="memItemLeft" align="right" valign="top"><a id="ga44715ea73b26246ec47ff7f72eca6a68"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fields.html#ga44715ea73b26246ec47ff7f72eca6a68">fantom::ColorFunction</a> = <a class="el" href="classfantom_1_1Function.html">Function</a>&lt; <a class="el" href="classfantom_1_1Color.html">Color</a> &gt;</td></tr>
<tr class="memdesc:ga44715ea73b26246ec47ff7f72eca6a68"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfantom_1_1Color.html" title="RGBA color.">Color</a> functions. <br /></td></tr>
<tr class="separator:ga44715ea73b26246ec47ff7f72eca6a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga016dcd8e44d216e0112cebd03281bd4f"><td class="memItemLeft" align="right" valign="top"><a id="ga016dcd8e44d216e0112cebd03281bd4f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fields.html#ga016dcd8e44d216e0112cebd03281bd4f">fantom::IntegerFunction</a> = <a class="el" href="classfantom_1_1Function.html">Function</a>&lt; <a class="el" href="group__math.html#gaf4e435e8e86130220eeced235b564cf9">Integer</a> &gt;</td></tr>
<tr class="memdesc:ga016dcd8e44d216e0112cebd03281bd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer functions. <br /></td></tr>
<tr class="separator:ga016dcd8e44d216e0112cebd03281bd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54814fe8ea6acacf0763a8b7981d7ad5"><td class="memTemplParams" colspan="2"><a id="ga54814fe8ea6acacf0763a8b7981d7ad5"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga54814fe8ea6acacf0763a8b7981d7ad5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fields.html#ga54814fe8ea6acacf0763a8b7981d7ad5">fantom::FunctionsOf</a> = <a class="el" href="structfantom_1_1TypeList.html">TypeList</a>&lt; <a class="el" href="classfantom_1_1Function.html">Function</a>&lt; Types &gt;... &gt;</td></tr>
<tr class="memdesc:ga54814fe8ea6acacf0763a8b7981d7ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfantom_1_1List.html" title="Simple data list.">List</a> of functions. <br /></td></tr>
<tr class="separator:ga54814fe8ea6acacf0763a8b7981d7ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2722b818aca1f0762978b31b379ffa7"><td class="memTemplParams" colspan="2"><a id="gab2722b818aca1f0762978b31b379ffa7"></a>
template&lt;size_t Dim, typename... Types&gt; </td></tr>
<tr class="memitem:gab2722b818aca1f0762978b31b379ffa7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fields.html#gab2722b818aca1f0762978b31b379ffa7">fantom::SpatialFunctionsOf</a> = <a class="el" href="structfantom_1_1TypeList.html">TypeList</a>&lt; <a class="el" href="classfantom_1_1SpatialFunction.html">SpatialFunction</a>&lt; Dim, Types &gt;... &gt;</td></tr>
<tr class="memdesc:gab2722b818aca1f0762978b31b379ffa7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfantom_1_1List.html" title="Simple data list.">List</a> of functions. <br /></td></tr>
<tr class="separator:gab2722b818aca1f0762978b31b379ffa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad96016abc36af3ed4ef0e575656dd4fd"><td class="memTemplParams" colspan="2"><a id="gad96016abc36af3ed4ef0e575656dd4fd"></a>
template&lt;size_t Dim, typename... Types&gt; </td></tr>
<tr class="memitem:gad96016abc36af3ed4ef0e575656dd4fd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fields.html#gad96016abc36af3ed4ef0e575656dd4fd">fantom::FieldsOf</a> = <a class="el" href="structfantom_1_1TypeList.html">TypeList</a>&lt; <a class="el" href="classfantom_1_1Field.html">Field</a>&lt; Dim, Types &gt;... &gt;</td></tr>
<tr class="memdesc:gad96016abc36af3ed4ef0e575656dd4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfantom_1_1List.html" title="Simple data list.">List</a> of Fields. <br /></td></tr>
<tr class="separator:gad96016abc36af3ed4ef0e575656dd4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac1724a57c7d15ac29aeee149c8a73837"><td class="memItemLeft" align="right" valign="top"><a id="gac1724a57c7d15ac29aeee149c8a73837"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fields.html#gac1724a57c7d15ac29aeee149c8a73837">fantom::isSurface</a> (const <a class="el" href="classfantom_1_1DataObject.html">DataObject</a> &amp;obj)</td></tr>
<tr class="memdesc:gac1724a57c7d15ac29aeee149c8a73837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acceptor function for detecting surface structures. <br /></td></tr>
<tr class="separator:gac1724a57c7d15ac29aeee149c8a73837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabff207abd831b295c7452305f7608a5d"><td class="memItemLeft" align="right" valign="top"><a id="gabff207abd831b295c7452305f7608a5d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fields.html#gabff207abd831b295c7452305f7608a5d">fantom::isSimplicial</a> (const <a class="el" href="classfantom_1_1DataObject.html">DataObject</a> &amp;obj)</td></tr>
<tr class="memdesc:gabff207abd831b295c7452305f7608a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acceptor function that tests whether a cell complex is simplicial. <br /></td></tr>
<tr class="separator:gabff207abd831b295c7452305f7608a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79f88acc119569960febf9abd2a51df6"><td class="memItemLeft" align="right" valign="top"><a id="ga79f88acc119569960febf9abd2a51df6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fields.html#ga79f88acc119569960febf9abd2a51df6">fantom::isLineset</a> (const <a class="el" href="classfantom_1_1DataObject.html">DataObject</a> &amp;obj)</td></tr>
<tr class="memdesc:ga79f88acc119569960febf9abd2a51df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acceptor function for detecting linesetss. <br /></td></tr>
<tr class="separator:ga79f88acc119569960febf9abd2a51df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aba99020f9573fb27b8ce1b38f282aa"><td class="memTemplParams" colspan="2">template&lt;typename DomainT &gt; </td></tr>
<tr class="memitem:ga6aba99020f9573fb27b8ce1b38f282aa"><td class="memTemplItemLeft" align="right" valign="top">static std::function&lt; bool(const <a class="el" href="classfantom_1_1DataObject.html">DataObject</a> &amp;) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fields.html#ga6aba99020f9573fb27b8ce1b38f282aa">fantom::definedOn</a> (const <a class="el" href="classfantom_1_1DomainPart.html">DomainPart</a> &amp;part=Domain::any)</td></tr>
<tr class="memdesc:ga6aba99020f9573fb27b8ce1b38f282aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acceptor function that checks whether a <em><a class="el" href="classfantom_1_1Function.html" title="Representation of data values on a discrete domain.">Function</a></em> is defined on a specific <em><a class="el" href="classfantom_1_1Domain.html" title="Discrete domain.">Domain</a></em> type.  <a href="group__fields.html#ga6aba99020f9573fb27b8ce1b38f282aa">More...</a><br /></td></tr>
<tr class="separator:ga6aba99020f9573fb27b8ce1b38f282aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f4d06c642585451ebdcef73dea45bd1"><td class="memTemplParams" colspan="2">template&lt;typename... Functor&gt; </td></tr>
<tr class="memitem:ga0f4d06c642585451ebdcef73dea45bd1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fields.html#ga0f4d06c642585451ebdcef73dea45bd1">fantom::_or</a> (Functor... func)</td></tr>
<tr class="memdesc:ga0f4d06c642585451ebdcef73dea45bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for creation of composed filter functions.  <a href="group__fields.html#ga0f4d06c642585451ebdcef73dea45bd1">More...</a><br /></td></tr>
<tr class="separator:ga0f4d06c642585451ebdcef73dea45bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b3fa307e1936ce83260ee449cbe102b"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:ga0b3fa307e1936ce83260ee449cbe102b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fields.html#ga0b3fa307e1936ce83260ee449cbe102b">fantom::allInBundle</a> (Functor func)</td></tr>
<tr class="memdesc:ga0b3fa307e1936ce83260ee449cbe102b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elevate a filter function on <a class="el" href="classfantom_1_1DataObject.html" title="Representation of an object that carries data that can be passed between algorithms.">DataObject</a> to a filter function on <a class="el" href="classfantom_1_1DataObjectBundle.html">DataObjectBundle</a>.  <a href="group__fields.html#ga0b3fa307e1936ce83260ee449cbe102b">More...</a><br /></td></tr>
<tr class="separator:ga0b3fa307e1936ce83260ee449cbe102b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a4e030b160bebe7297db03386f3196b"><td class="memTemplParams" colspan="2">template&lt;typename... Types, typename Functor , typename Data &gt; </td></tr>
<tr class="memitem:ga1a4e030b160bebe7297db03386f3196b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fields.html#ga1a4e030b160bebe7297db03386f3196b">fantom::applyFor</a> (const Data &amp;d, Functor &amp;&amp;func)</td></tr>
<tr class="memdesc:ga1a4e030b160bebe7297db03386f3196b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a functor with the casted data when d can be cast to any of the specified types.  <a href="group__fields.html#ga1a4e030b160bebe7297db03386f3196b">More...</a><br /></td></tr>
<tr class="separator:ga1a4e030b160bebe7297db03386f3196b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad33a907fd2b18bdf9c8dcf9de7cb51b2"><td class="memTemplParams" colspan="2">template&lt;typename... Types, typename Functor , typename Data &gt; </td></tr>
<tr class="memitem:gad33a907fd2b18bdf9c8dcf9de7cb51b2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fields.html#gad33a907fd2b18bdf9c8dcf9de7cb51b2">fantom::applyFor</a> (const std::shared_ptr&lt; const Data &gt; &amp;d, Functor &amp;&amp;func)</td></tr>
<tr class="memdesc:gad33a907fd2b18bdf9c8dcf9de7cb51b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a functor with the casted data when d can be cast to any of the specified types.  <a href="group__fields.html#gad33a907fd2b18bdf9c8dcf9de7cb51b2">More...</a><br /></td></tr>
<tr class="separator:gad33a907fd2b18bdf9c8dcf9de7cb51b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This part of the tutorial shows how to work with tensor fields and grids. It also demonstrates the use of OpenMP to enable parallel computation. If the OpenMP statements confuse you, you can ignore them completely; the code also describes the single-threaded version. The tutorial does not aim to be an exhaustive description of OpenMP's features and API; you can easily find such things on the web. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fantom/algorithm.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fantom/datastructures/interfaces/Field.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fantom/graphics.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fantom/register.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;math.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// needed for BoundinSphere-Calculation</span></div>
<div class="line"><span class="preprocessor">#include &lt;fantom-plugins/utils/Graphics/HelperFunctions.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacefantom.html">fantom</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace</span></div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">class </span>FieldsTutorialAlgorithm : <span class="keyword">public</span> <a class="code" href="classfantom_1_1VisAlgorithm.html">VisAlgorithm</a></div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">struct </span><a class="code" href="classfantom_1_1Options.html">Options</a> : <span class="keyword">public</span> <a class="code" href="classfantom_1_1Algorithm.html#afd2cdec3a4e63e05e3f7003b656845b3">VisAlgorithm::Options</a></div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="classfantom_1_1Options.html">Options</a>( <a class="code" href="classfantom_1_1Options_1_1Control.html">fantom::Options::Control</a>&amp; control )</div>
<div class="line">                : <a class="code" href="classfantom_1_1VisAlgorithm.html">VisAlgorithm</a>::<a class="code" href="classfantom_1_1Options.html">Options</a>( control )</div>
<div class="line">            {</div>
<div class="line">                add&lt; Field&lt; 3, Vector3 &gt; &gt;( <span class="stringliteral">&quot;Field&quot;</span>, <span class="stringliteral">&quot;A 3D vector field&quot;</span>, definedOn&lt; Grid&lt; 3 &gt; &gt;( <a class="code" href="classfantom_1_1Grid.html">Grid&lt; 3 &gt;::Points</a> ) );</div>
<div class="line">                add&lt; double &gt;( <span class="stringliteral">&quot;Time&quot;</span>, <span class="stringliteral">&quot;The time when to sample the field.&quot;</span>, 0.0 );</div>
<div class="line">                add&lt; double &gt;( <span class="stringliteral">&quot;Scale&quot;</span>, <span class="stringliteral">&quot;The size of the graphics.&quot;</span>, 1.0 );</div>
<div class="line">                add&lt; Color &gt;( <span class="stringliteral">&quot;Color&quot;</span>, <span class="stringliteral">&quot;The color of the graphics.&quot;</span>, <a class="code" href="classfantom_1_1Color.html">Color</a>( 0.75, 0.75, 0.0 ) );</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">struct </span><a class="code" href="classfantom_1_1VisOutputs.html">VisOutputs</a> : <span class="keyword">public</span> <a class="code" href="classfantom_1_1VisOutputs.html">VisAlgorithm::VisOutputs</a></div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="classfantom_1_1VisOutputs.html">VisOutputs</a>( fantom::VisOutputs::Control&amp; control )</div>
<div class="line">                : <a class="code" href="classfantom_1_1VisAlgorithm.html">VisAlgorithm</a>::<a class="code" href="classfantom_1_1VisOutputs.html">VisOutputs</a>( control )</div>
<div class="line">            {</div>
<div class="line">                addGraphics( <span class="stringliteral">&quot;Glyphs&quot;</span> );</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        FieldsTutorialAlgorithm( InitData&amp; data )</div>
<div class="line">            : <a class="code" href="classfantom_1_1VisAlgorithm.html">VisAlgorithm</a>( data )</div>
<div class="line">        {</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> execute( <span class="keyword">const</span> <a class="code" href="classfantom_1_1Options.html">Algorithm::Options</a>&amp; options, <span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keywordtype">bool</span>&amp; abortFlag )<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            std::shared_ptr&lt; const Field&lt; 3, Vector3 &gt; &gt; field = options.<a class="code" href="classfantom_1_1Options.html#ae454b0a66e9ddbde305ef9ec099b34b9">get</a>&lt; <a class="code" href="classfantom_1_1Field.html">Field&lt; 3, Vector3 &gt;</a> &gt;( <span class="stringliteral">&quot;Field&quot;</span> );</div>
<div class="line"> </div>
<div class="line">            std::shared_ptr&lt; const Function&lt; Vector3 &gt; &gt; <span class="keyword">function</span> = options.<a class="code" href="classfantom_1_1Options.html#ae454b0a66e9ddbde305ef9ec099b34b9">get</a>&lt; <a class="code" href="classfantom_1_1Function.html">Function&lt; Vector3 &gt;</a> &gt;( <span class="stringliteral">&quot;Field&quot;</span> );</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// if there is no input, do nothing</span></div>
<div class="line">            <span class="keywordflow">if</span>( !field )</div>
<div class="line">            {</div>
<div class="line">                debugLog() &lt;&lt; <span class="stringliteral">&quot;Input Field not set.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// sanity check that interpolated fields really use the correct grid type. This should never fail</span></div>
<div class="line">            std::shared_ptr&lt; const Grid&lt; 3 &gt; &gt; grid</div>
<div class="line">                = std::dynamic_pointer_cast&lt; const Grid&lt; 3 &gt; &gt;( <span class="keyword">function</span>-&gt;domain() );</div>
<div class="line">            <span class="keywordflow">if</span>( !grid )</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">throw</span> std::logic_error( <span class="stringliteral">&quot;Wrong type of grid!&quot;</span> );</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="keywordtype">double</span> scale = options.<a class="code" href="classfantom_1_1Options.html#ae454b0a66e9ddbde305ef9ec099b34b9">get</a>&lt; <span class="keywordtype">double</span> &gt;( <span class="stringliteral">&quot;Scale&quot;</span> );</div>
<div class="line">            <span class="keywordtype">double</span> time = options.<a class="code" href="classfantom_1_1Options.html#ae454b0a66e9ddbde305ef9ec099b34b9">get</a>&lt; <span class="keywordtype">double</span> &gt;( <span class="stringliteral">&quot;Time&quot;</span> );</div>
<div class="line">            <a class="code" href="classfantom_1_1Color.html">Color</a> color = options.<a class="code" href="classfantom_1_1Options.html#ae454b0a66e9ddbde305ef9ec099b34b9">get</a>&lt; <a class="code" href="classfantom_1_1Color.html">Color</a> &gt;( <span class="stringliteral">&quot;Color&quot;</span> );</div>
<div class="line"> </div>
<div class="line">            <span class="keyword">const</span> <a class="code" href="classfantom_1_1ValueArray.html">ValueArray&lt; Point3 &gt;</a>&amp; points = grid-&gt;points();</div>
<div class="line">            std::vector&lt; VectorF&lt; 3 &gt; &gt; vertices( 2 * grid-&gt;numCells() );</div>
<div class="line">            <span class="keywordtype">double</span> maximum = 0.0;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma omp parallel</span></div>
<div class="line">            {</div>
<div class="line">                Progress progress( *<span class="keyword">this</span>, <span class="stringliteral">&quot;Processing cells&quot;</span>, 0, <span class="keyword">false</span> );</div>
<div class="line"> </div>
<div class="line">                <span class="keywordtype">size_t</span> i;</div>
<div class="line">                <span class="keywordtype">double</span> locMaximum = 0.0;</div>
<div class="line"> </div>
<div class="line">                <span class="keyword">auto</span> evaluator = field-&gt;makeEvaluator();</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma omp for nowait</span></div>
<div class="line">                <span class="keywordflow">for</span>( i = 0; i &lt; grid-&gt;numCells(); ++i )</div>
<div class="line">                {</div>
<div class="line">                    <span class="keywordflow">if</span>( abortFlag )</div>
<div class="line">                    {</div>
<div class="line">                        <span class="keywordflow">continue</span>;</div>
<div class="line">                    }</div>
<div class="line"> </div>
<div class="line">                    <a class="code" href="classfantom_1_1Cell.html">Cell</a> cell = grid-&gt;cell( i );</div>
<div class="line"> </div>
<div class="line">                    <a class="code" href="classfantom_1_1Tensor.html">Point3</a> point;</div>
<div class="line">                    <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> j = 0; j != cell.<a class="code" href="classfantom_1_1Cell.html#aba572432294d90c7cbac5956ef49121e">numVertices</a>(); ++j )</div>
<div class="line">                    {</div>
<div class="line">                        point += points[cell.<a class="code" href="classfantom_1_1Cell.html#a69804d0f987a7f864aa514a32a172e2a">index</a>( j )];</div>
<div class="line">                    }</div>
<div class="line"> </div>
<div class="line">                    point /= cell.<a class="code" href="classfantom_1_1Cell.html#aba572432294d90c7cbac5956ef49121e">numVertices</a>();</div>
<div class="line"> </div>
<div class="line">                    <span class="keywordflow">if</span>( evaluator-&gt;reset( point, time ) )</div>
<div class="line">                    {</div>
<div class="line">                        <span class="keyword">auto</span> v = evaluator-&gt;value();</div>
<div class="line">                        locMaximum = std::max( locMaximum, norm( v ) );</div>
<div class="line">                        vertices[2 * i + 0] = <a class="code" href="classfantom_1_1Tensor.html">VectorF&lt; 3 &gt;</a>( point );</div>
<div class="line">                        vertices[2 * i + 1] = <a class="code" href="classfantom_1_1Tensor.html">VectorF&lt; 3 &gt;</a>( v );</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma omp critical</span></div>
<div class="line">                maximum = std::max( maximum, locMaximum );</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma omp barrier</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma omp for nowait</span></div>
<div class="line">                <span class="keywordflow">for</span>( i = 0; i &lt; grid-&gt;numCells(); ++i )</div>
<div class="line">                {</div>
<div class="line">                    <span class="keywordflow">if</span>( abortFlag )</div>
<div class="line">                    {</div>
<div class="line">                        <span class="keywordflow">continue</span>;</div>
<div class="line">                    }</div>
<div class="line"> </div>
<div class="line">                    vertices[2 * i + 1] = vertices[2 * i + 0] + vertices[2 * i + 1] / (float)maximum * (<span class="keywordtype">float</span>)scale;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span>( abortFlag )</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// The GraphicsSystem is needed to create the Drawable, which defines the objects to render.</span></div>
<div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span>&amp; system = graphics::GraphicsSystem::instance();</div>
<div class="line">            <span class="comment">// This is the path to the resources folder, where you can find the shaders.</span></div>
<div class="line">            std::string resourcePath = PluginRegistrationService::getInstance().getResourcePath( <span class="stringliteral">&quot;utils/Graphics&quot;</span> );</div>
<div class="line">            <span class="comment">// The BoundingSphere should contain all elements of the drawable and is needed fot its creation.</span></div>
<div class="line">            <span class="keyword">auto</span> bs = <a class="code" href="group__gfx.html#ga016aefcd06acfd0cf24ebed11ea6ae18">graphics::computeBoundingSphere</a>( vertices );</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">            std::shared_ptr&lt; graphics::Drawable &gt; glyphs = system.makePrimitive(</div>
<div class="line">                <a class="code" href="classfantom_1_1graphics_1_1PrimitiveConfig.html">graphics::PrimitiveConfig</a>{ graphics::RenderPrimitives::LINES }</div>
<div class="line">                    .vertexBuffer( <span class="stringliteral">&quot;in_vertex&quot;</span>, system.makeBuffer( vertices ) )</div>
<div class="line">                    .uniform( <span class="stringliteral">&quot;u_lineWidth&quot;</span>, 1.0f )</div>
<div class="line">                    .uniform( <span class="stringliteral">&quot;u_color&quot;</span>, color )</div>
<div class="line">                    .boundingSphere( bs ),</div>
<div class="line">                system.makeProgramFromFiles( resourcePath + <span class="stringliteral">&quot;shader/line/noShading/singleColor/vertex.glsl&quot;</span>,</div>
<div class="line">                                             resourcePath + <span class="stringliteral">&quot;shader/line/noShading/singleColor/fragment.glsl&quot;</span>,</div>
<div class="line">                                             resourcePath + <span class="stringliteral">&quot;shader/line/noShading/singleColor/geometry.glsl&quot;</span> ) );</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// set the Drawable as the graphics output</span></div>
<div class="line">            setGraphics( <span class="stringliteral">&quot;Glyphs&quot;</span>, glyphs );</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classfantom_1_1AlgorithmRegister.html">AlgorithmRegister&lt; FieldsTutorialAlgorithm &gt;</a> dummy( <span class="stringliteral">&quot;Tutorial/Fields&quot;</span>,</div>
<div class="line">                                                        <span class="stringliteral">&quot;Show vector field glyphs at cell centers.&quot;</span> );</div>
<div class="line">} <span class="comment">// namespace</span></div>
</div><!-- fragment --><p>When started, the algorithm draws small lines at the center of the selected field's cells, their direction and length orienting themselves at the three dimensional vectors of the field. The glyphs are also scaled so that the longest glyph has the length given by the <code>scale</code> algorithm option.</p>
<div class="fragment"></div><!-- fragment --><p>The representation of data in fantom is split in two parts. The first part is the domain, which contains sets of elements on which mappings (or Functions) can be defined. Each domain consists of one or multiple parts. These are discrete and distinct sets of elements that characterize compartments of the domain. E.g., a domain can be a set of points in the Euclidean space, or a grid consisting of point set and cell complex, or a graph consisting of vertex and edge sets.</p>
<p>Data can be registered on top of a domain (with reference to the respective domain part) by means of Function. The goal of this design is to have an easy interface to the data that is independent from the specific domain the data is registered on (regarding the C++ type). This makes it easy to write common and general algorithms that only process data without needing to know the domain type. All domain-related data is encoded in the meta-data and is easily copyable. This allows for truly domain-agnostic algorithms without the disadvantage that the domain-related data would be pruned.</p>
<p>Field inherits from DataObject, an abstract class, that has access to a Function and the domain it is specified on. It also implements methods for continuous interpolation.</p>
<p>To use fields in your algorithm, include "dataset.hpp".</p>
<div class="fragment"></div><!-- fragment --><p>Among other options, the example declares options for selecting a 3-D vector field. The template parameter of Field specifies the value type of the co-domain.</p>
<p>Alternatively, different kinds of functions and domains can be specified as input, if that is sufficient for the algorithm.</p>
<p>It is also possible to select any type of functions and domains independent of dimension and value type by using the classes <code>FunctionBase</code> and <code>DomainBase</code>, from which all functions and domains derive from, as algorithm options. In this case, you can use option callbacks to restrict yourself to certain types of tensor fields, e.g. vector fields.</p>
<div class="fragment"></div><!-- fragment --><p>Retrieving the vector field from the algorithm options is straight-forward. Note that to prevent manipulation, you always get a shared_ptr to const data objects. Extracting the domain and checking it for the correct type is also straight-forward.</p>
<p>Note that it is always possible to select no field or grid (some algorithms use this feature for optional parameters); then the pointer passed to the algorithm is empty. Therefore you should always check whether the options were really set.</p>
<div class="fragment"></div><!-- fragment --><p>This constructs and initializes some variables that are shared for the upcoming computation. The points holds the locations in space on which the cells are defined. The <code>vertices</code> will be written to the start and end point of each glyph, hence its size is twice the number of cells. (Some cells may not lie inside the given field, in this case their glyphs will have zero size). The maximum will be maximum vector norm over all field samples.</p>
<div class="fragment"></div><!-- fragment --><p>This starts parallel processing by OpenMP. The following block will be executed once for each thread. The number of threads created by OpenMP is typically the number of CPU cores, and can be modified by the environment variable <code>OMP_NUM_THREADS</code>.</p>
<div class="fragment"></div><!-- fragment --><p>Typically when working with OpenMP statements you have to define which variables are shared between threads and which are local to each thread. Fortunately C++ scopes make this definition mostly superfluous, everything before the pragma above is automatically shared and everything inside the block is private to the thread. In the example there is a progress indicator for each thread, a loop variable, and a variable for the maximum norm of the vectors which are sampled by this thread. To avoid bottlenecks originating from synchronizing concurrently writing shared data, most parallel computation should write mostly on private data and only combine their results into shared memory when they are finished.</p>
<div class="fragment"></div><!-- fragment --><p>Among the private variables is an evaluator for the tensor field. An evaluator is used to determine the value at arbitrary points in the field. Each evaluator contains an internal cache that accelerates evaluations of close field locations, i.e. it is optimized for integral line computations. The evaluator cache is not thread-safe, and multi-threaded algorithms should create an evaluator for each thread. This is why we chose to use a private variable for the evaluator, in contrast to e.g. the points variable.</p>
<p>A thread may create multiple evaluators to support better caching, e.g. when an integral surface is constructed by advancing multiple integral lines simultaneously, each line should have its own evaluator.</p>
<div class="fragment"></div><!-- fragment --><p>This pragma tells OpenMP to run the following loop parallel in the threads it created. To this end it distributes chunks of ranges between <code>0</code> and <code>size</code> among them, i.e. no thread works on the same value of <code>i</code>. The <code>nowait</code> at the end just tells OpenMP that is should not synchronize the loops at the end using a barrier (the default when omitting <code>nowait</code>); we will perform explicit synchronization later.</p>
<div class="fragment"></div><!-- fragment --><p>The i-th cell of a grid is obtained via <code>Grid::cell(i)</code>. The example determines the barycenter of a cell by averaging over its control points' positions. The cells do not store the positions directly, but they can be fetched via using cell indices on the value array of points.</p>
<p>Although not used in this tutorial, there is also the member function <code>Cell::numFaces()</code> that retrieves the number of faces of a cell and <code>Cell::face(i)</code> that retrieves the i-th face. The return value of the latter function is a cell again. Faces are oriented so that iterating over their points performs counter-clockwise traversal in 2-D, and in 3-D the normal obtained by the cross product of (p0-p1)x(p2-p1) points away from the cell.</p>
<div class="fragment"></div><!-- fragment --><p>This second part of the loop shows how to evaluate a tensor field. First, the current position and time is set using <code>Evaluator::reset()</code>. It returns a value that is true if the new position is inside the domain, and false otherwise. The value at the position can then obtained via <code>Evaluator::value()</code>. <code>Evaluator::reset()</code> requires that the provided time is inside the time range of the tensor field and <code>Evaluate::value()</code> requires that the current location is inside the domain.</p>
<p>Concerning parallel processing, note two things: first we update <code>maximum</code> that is private to the thread and we set the start point and direction of a glyph in <code>vertices</code> (They will be turned into a point pair later on). All access to shared memory must be synchronized explicitly unless no thread writes on the same spot of memory at the same time. In this case since no thread works on the same value for <code>i</code> , only one thread will store each value, and the above code is safe.</p>
<div class="fragment"></div><!-- fragment --><p>A different case it is with the shared variable <code>maximum</code>. Here all threads will try to update it, hence we need to synchronize in order to avoid a race condition. By using the above pragma, the statement updating the maximum will be executed by only one thread at a time. If an algorithm uses a simpler reduction operator, e.g. like <code>+</code> , the faster <code>atomic</code> may be used instead of <code>critical</code>.</p>
<div class="fragment"></div><!-- fragment --><p>This pragma also performs a synchronization. A barrier waits for all threads to reach this point and then lets them proceed. We need the barrier to ensure that all threads have combined their private maximum with the shared maximum.</p>
<div class="fragment"></div><!-- fragment --><p>Then we go through all glyphs again in parallel and construct their second point from the first point and the temporarily stored direction which can now be normalized using the shared maximum and the desired scale. Note that writing into the array is safe again as no thread works on the same <code>i</code> and reading the global maximum is safe as no one writes it anymore. Again we use a <code>nowait</code> in the pragma because a barrier at the end of the loop is not necessary; it is performed implicitly at the end of the parallel section.</p>
<div class="fragment"></div><!-- fragment --><p>The algorithm finishes by committing the vertices as endpoints of simple lines.</p>
<p>When writing parallel algorithms you should be extra careful with shared variables which you write to.These are often hidden in other function calls. For instance you should not use writing to <code>std::cout</code> as this accesses a global variable often causing crashes or at least unreadable output. Concerning speed you should also avoid using too much synchronization. This again may be hidden in seemingly harmless function calls. Most notably are the operators <code>new</code> and <code>delete</code> which use system calls that are synchronized automatically. These are hidden in almost all standard containers like vector, string, list, map, unordered_map, and are called when elements are added or removed from these contains. This is why we set the size of the vector <code>vertices</code> before entering the parallel section. Always avoid synchronization inside parallel loops, unless it introduces race conditions. Try to move construction, destruction and resizing operations on standard containers outside the loop. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6aba99020f9573fb27b8ce1b38f282aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6aba99020f9573fb27b8ce1b38f282aa">&#9670;&nbsp;</a></span>definedOn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DomainT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::function&lt; bool( const <a class="el" href="classfantom_1_1DataObject.html">DataObject</a>&amp; ) &gt; fantom::definedOn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfantom_1_1DomainPart.html">DomainPart</a> &amp;&#160;</td>
          <td class="paramname"><em>part</em> = <code>Domain::any</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acceptor function that checks whether a <em><a class="el" href="classfantom_1_1Function.html" title="Representation of data values on a discrete domain.">Function</a></em> is defined on a specific <em><a class="el" href="classfantom_1_1Domain.html" title="Discrete domain.">Domain</a></em> type. </p>
<p>The domain type is specified as a template parameter. The domain part is specified at runtime with the function parameter. Leave it empty to allow for functions on any domain part.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DomainT</td><td>A type or <a class="el" href="structfantom_1_1TypeList.html" title="Simple type list interface.">TypeList</a> of Domains. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>The <a class="el" href="classfantom_1_1DomainPart.html" title="Representation of a part of a domain, for example the points of a grid, the edges of a graph,...">DomainPart</a> on which the data should be defined. Use Domain::any to let it remain unspecified.</td></tr>
  </table>
  </dd>
</dl>
<p>Usage example: add&lt; Function&lt; Scalar &gt; &gt;( "Values", "A scalar array on a grid", definedOn&lt; Grid&lt; 3 &gt; &gt;( <a class="el" href="classfantom_1_1PointSetBase.html#af832a6a8d33d16287bf7940bcdca1aa9" title="Part that represents the cells of this cell complex.">Grid&lt; 3 &gt;::Points</a> ) ); </p>

</div>
</div>
<a id="ga0f4d06c642585451ebdcef73dea45bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f4d06c642585451ebdcef73dea45bd1">&#9670;&nbsp;</a></span>_or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Functor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto fantom::_or </td>
          <td>(</td>
          <td class="paramtype">Functor...&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for creation of composed filter functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The filter functions that will be or-composed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Functor</td><td>the type of the filter functions.</td></tr>
  </table>
  </dd>
</dl>
<p>Usage: add&lt; FunctionBase &gt;( "name", "description", _or( definedOn&lt; Grid&lt;2&gt; &gt;(), definedOn&lt; Grid&lt;3&gt; &gt;() ) ); </p>

</div>
</div>
<a id="ga0b3fa307e1936ce83260ee449cbe102b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b3fa307e1936ce83260ee449cbe102b">&#9670;&nbsp;</a></span>allInBundle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto fantom::allInBundle </td>
          <td>(</td>
          <td class="paramtype">Functor&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elevate a filter function on <a class="el" href="classfantom_1_1DataObject.html" title="Representation of an object that carries data that can be passed between algorithms.">DataObject</a> to a filter function on <a class="el" href="classfantom_1_1DataObjectBundle.html">DataObjectBundle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>the filter function </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Functor</td><td>the type of the filter function</td></tr>
  </table>
  </dd>
</dl>
<p>Usage: addBundle&lt; FunctionBase &gt;( "name", "description", allInBundle( definedOn&lt; Grid&lt;2&gt; &gt;() ) ); </p>

</div>
</div>
<a id="ga1a4e030b160bebe7297db03386f3196b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a4e030b160bebe7297db03386f3196b">&#9670;&nbsp;</a></span>applyFor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types, typename Functor , typename Data &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool fantom::applyFor </td>
          <td>(</td>
          <td class="paramtype">const Data &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a functor with the casted data when d can be cast to any of the specified types. </p>
<p>The function can be used for easy type multiplexing, e.g., when handling multiple possible input types. In the easiest case, this is combined with C++14 generic lambdas for handling the visiting, though any struct with overloaded operator() for all types in the type list would do, also.</p>
<p>Usage: applyFor&lt; Function&lt; Scalar &gt;, Function&lt; Vector2 &gt;, Function&lt; Vector3 &gt; &gt;( dataObject, []( auto&amp; field ) { // do something } );</p>
<dl class="section return"><dt>Returns</dt><dd>true if any cast was successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>the data that should be cast </td></tr>
    <tr><td class="paramname">func</td><td>the functor that will be called </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Types</td><td>A list of types that the cast will be tried for. Also <a class="el" href="structfantom_1_1TypeList.html" title="Simple type list interface.">TypeList</a>'s can be used. </td></tr>
    <tr><td class="paramname">Functor</td><td>the functor type (auto-deduced!) </td></tr>
    <tr><td class="paramname">Data</td><td>the type of the data (auto-deduced!) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad33a907fd2b18bdf9c8dcf9de7cb51b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad33a907fd2b18bdf9c8dcf9de7cb51b2">&#9670;&nbsp;</a></span>applyFor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types, typename Functor , typename Data &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool fantom::applyFor </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const Data &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a functor with the casted data when d can be cast to any of the specified types. </p>
<p>Overload for shared_ptrs.</p>
<p>Call a functor with the casted data when d can be cast to any of the specified types. The function can be used for easy type multiplexing, e.g., when handling multiple possible input types. In the easiest case, this is combined with C++14 generic lambdas for handling the visiting, though any struct with overloaded operator() for all types in the type list would do, also.</p>
<p>Usage: applyFor&lt; Function&lt; Scalar &gt;, Function&lt; Vector2 &gt;, Function&lt; Vector3 &gt; &gt;( dataObject, []( auto&amp; field ) { // do something } );</p>
<dl class="section return"><dt>Returns</dt><dd>true if any cast was successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>the data that should be cast </td></tr>
    <tr><td class="paramname">func</td><td>the functor that will be called </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Types</td><td>A list of types that the cast will be tried for. Also <a class="el" href="structfantom_1_1TypeList.html" title="Simple type list interface.">TypeList</a>'s can be used. </td></tr>
    <tr><td class="paramname">Functor</td><td>the functor type (auto-deduced!) </td></tr>
    <tr><td class="paramname">Data</td><td>the type of the data (auto-deduced!) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="aclassfantom_1_1Color_html"><div class="ttname"><a href="classfantom_1_1Color.html">fantom::Color</a></div><div class="ttdoc">RGBA color.</div><div class="ttdef"><b>Definition:</b> math.hpp:1619</div></div>
<div class="ttc" id="aclassfantom_1_1graphics_1_1PrimitiveConfig_html"><div class="ttname"><a href="classfantom_1_1graphics_1_1PrimitiveConfig.html">fantom::graphics::PrimitiveConfig</a></div><div class="ttdef"><b>Definition:</b> PrimitiveConfig.hpp:39</div></div>
<div class="ttc" id="aclassfantom_1_1Function_html"><div class="ttname"><a href="classfantom_1_1Function.html">fantom::Function</a></div><div class="ttdoc">Representation of data values on a discrete domain.</div><div class="ttdef"><b>Definition:</b> Function.hpp:323</div></div>
<div class="ttc" id="aclassfantom_1_1Options_1_1Control_html"><div class="ttname"><a href="classfantom_1_1Options_1_1Control.html">fantom::Options::Control</a></div><div class="ttdoc">Private implementation of Options.</div><div class="ttdef"><b>Definition:</b> options.hpp:456</div></div>
<div class="ttc" id="aclassfantom_1_1AlgorithmRegister_html"><div class="ttname"><a href="classfantom_1_1AlgorithmRegister.html">fantom::AlgorithmRegister</a></div><div class="ttdoc">registers an algorithm at the kernel</div><div class="ttdef"><b>Definition:</b> algorithm.hpp:291</div></div>
<div class="ttc" id="aclassfantom_1_1VisAlgorithm_html"><div class="ttname"><a href="classfantom_1_1VisAlgorithm.html">fantom::VisAlgorithm</a></div><div class="ttdoc">base class of visualization algorithms</div><div class="ttdef"><b>Definition:</b> algorithm.hpp:203</div></div>
<div class="ttc" id="anamespacefantom_html"><div class="ttname"><a href="namespacefantom.html">fantom</a></div><div class="ttdoc">FAnToM API namespace.</div><div class="ttdef"><b>Definition:</b> main.dox:37</div></div>
<div class="ttc" id="aclassfantom_1_1Options_html_ae454b0a66e9ddbde305ef9ec099b34b9"><div class="ttname"><a href="classfantom_1_1Options.html#ae454b0a66e9ddbde305ef9ec099b34b9">fantom::Options::get</a></div><div class="ttdeci">input_detail::InputTypeTraits&lt; T &gt;::ValueType get(const std::string &amp;name) const</div><div class="ttdoc">Gives the value of an option.</div><div class="ttdef"><b>Definition:</b> options.hpp:590</div></div>
<div class="ttc" id="aclassfantom_1_1Algorithm_html_afd2cdec3a4e63e05e3f7003b656845b3"><div class="ttname"><a href="classfantom_1_1Algorithm.html#afd2cdec3a4e63e05e3f7003b656845b3">fantom::Algorithm::Options</a></div><div class="ttdeci">fantom::Options Options</div><div class="ttdoc">Base class for algorithm specific options.</div><div class="ttdef"><b>Definition:</b> algorithm.hpp:70</div></div>
<div class="ttc" id="agroup__gfx_html_ga016aefcd06acfd0cf24ebed11ea6ae18"><div class="ttname"><a href="group__gfx.html#ga016aefcd06acfd0cf24ebed11ea6ae18">fantom::graphics::computeBoundingSphere</a></div><div class="ttdeci">BoundingSphere computeBoundingSphere(const std::vector&lt; Tensor&lt; float, 3 &gt; &gt; &amp;points)</div><div class="ttdoc">This function computes a suitable bounding sphere for an array of points.</div></div>
<div class="ttc" id="aclassfantom_1_1Tensor_html"><div class="ttname"><a href="classfantom_1_1Tensor.html">fantom::Tensor&lt; double, 3 &gt;</a></div></div>
<div class="ttc" id="aclassfantom_1_1Options_html"><div class="ttname"><a href="classfantom_1_1Options.html">fantom::Options</a></div><div class="ttdoc">base class of options</div><div class="ttdef"><b>Definition:</b> options.hpp:119</div></div>
<div class="ttc" id="aclassfantom_1_1Cell_html"><div class="ttname"><a href="classfantom_1_1Cell.html">fantom::Cell</a></div><div class="ttdoc">reference to a grid cell</div><div class="ttdef"><b>Definition:</b> cells.hpp:94</div></div>
<div class="ttc" id="aclassfantom_1_1Cell_html_aba572432294d90c7cbac5956ef49121e"><div class="ttname"><a href="classfantom_1_1Cell.html#aba572432294d90c7cbac5956ef49121e">fantom::Cell::numVertices</a></div><div class="ttdeci">size_t numVertices() const</div><div class="ttdoc">Determines the number of control points.</div><div class="ttdef"><b>Definition:</b> cells.hpp:292</div></div>
<div class="ttc" id="aclassfantom_1_1VisOutputs_html"><div class="ttname"><a href="classfantom_1_1VisOutputs.html">fantom::VisOutputs</a></div><div class="ttdoc">Visual outputs of algorithms.</div><div class="ttdef"><b>Definition:</b> VisOutputs.hpp:40</div></div>
<div class="ttc" id="aclassfantom_1_1ValueArray_html"><div class="ttname"><a href="classfantom_1_1ValueArray.html">fantom::ValueArray</a></div><div class="ttdoc">an array which stores data</div><div class="ttdef"><b>Definition:</b> ValueArray.hpp:65</div></div>
<div class="ttc" id="aclassfantom_1_1Grid_html"><div class="ttname"><a href="classfantom_1_1Grid.html">fantom::Grid</a></div><div class="ttdoc">Representation of grids.</div><div class="ttdef"><b>Definition:</b> Grid.hpp:24</div></div>
<div class="ttc" id="aclassfantom_1_1Field_html"><div class="ttname"><a href="classfantom_1_1Field.html">fantom::Field</a></div><div class="ttdoc">An analytical or interpolated tensor field.</div><div class="ttdef"><b>Definition:</b> Field.hpp:109</div></div>
<div class="ttc" id="aclassfantom_1_1Cell_html_a69804d0f987a7f864aa514a32a172e2a"><div class="ttname"><a href="classfantom_1_1Cell.html#a69804d0f987a7f864aa514a32a172e2a">fantom::Cell::index</a></div><div class="ttdeci">size_t index(size_t i) const</div><div class="ttdoc">Determines the i-th control point.</div><div class="ttdef"><b>Definition:</b> cells.hpp:320</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
