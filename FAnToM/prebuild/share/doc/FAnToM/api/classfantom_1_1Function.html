<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FAnToM: fantom::Function&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="FAnToM-logo.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FAnToM
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">scientific visualization and analysis</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacefantom.html">fantom</a></li><li class="navelem"><a class="el" href="classfantom_1_1Function.html">Function</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="classfantom_1_1Function-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fantom::Function&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__fields.html">Fields, Grids, and Cells</a> &#124; <a class="el" href="group__commit.html">Committing Field Data</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Representation of data values on a discrete domain.  
 <a href="classfantom_1_1Function.html#details">More...</a></p>

<p><code>#include &lt;Function.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for fantom::Function&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classfantom_1_1Function__inherit__graph.png" border="0" usemap="#fantom_1_1Function_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="fantom_1_1Function_3_01T_01_4_inherit__map" id="fantom_1_1Function_3_01T_01_4_inherit__map">
<area shape="rect" title="Representation of data values on a discrete domain." alt="" coords="5,229,157,256"/>
<area shape="rect" href="classfantom_1_1FunctionBase.html" title="Base class for discrete (sample&#45;based) functions on Domains." alt="" coords="6,155,157,181"/>
<area shape="rect" href="classfantom_1_1DataObject.html" title="Representation of an object that carries data that can be passed between algorithms." alt="" coords="13,80,149,107"/>
<area shape="rect" href="classfantom_1_1RTTI.html" title="Base class of all typed objects." alt="" coords="31,5,131,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for fantom::Function&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classfantom_1_1Function__coll__graph.png" border="0" usemap="#fantom_1_1Function_3_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="fantom_1_1Function_3_01T_01_4_coll__map" id="fantom_1_1Function_3_01T_01_4_coll__map">
<area shape="rect" title="Representation of data values on a discrete domain." alt="" coords="117,247,269,273"/>
<area shape="rect" href="classfantom_1_1FunctionBase.html" title="Base class for discrete (sample&#45;based) functions on Domains." alt="" coords="118,171,269,197"/>
<area shape="rect" href="classfantom_1_1DataObject.html" title="Representation of an object that carries data that can be passed between algorithms." alt="" coords="5,81,141,108"/>
<area shape="rect" href="classfantom_1_1RTTI.html" title="Base class of all typed objects." alt="" coords="23,5,123,32"/>
<area shape="rect" href="classfantom_1_1DomainPart.html" title="Representation of a part of a domain, for example the points of a grid, the edges of a graph,..." alt="" coords="165,81,304,108"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a79f00225719fc0f60a76443053e3cced"><td class="memItemLeft" align="right" valign="top"><a id="a79f00225719fc0f60a76443053e3cced"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1Function.html#a79f00225719fc0f60a76443053e3cced">DataType</a> = T</td></tr>
<tr class="memdesc:a79f00225719fc0f60a76443053e3cced"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying data type. Use to query default types, like <a class="el" href="classfantom_1_1Function.html#a79f00225719fc0f60a76443053e3cced" title="The underlying data type. Use to query default types, like ScalarFunction::DataType.">ScalarFunction::DataType</a>. <br /></td></tr>
<tr class="separator:a79f00225719fc0f60a76443053e3cced"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7c703e5e1a206900989d7ea9da7c6ba7"><td class="memItemLeft" align="right" valign="top">virtual const fantom::RTTI::TypeId &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1Function.html#a7c703e5e1a206900989d7ea9da7c6ba7">typeId</a> () const override</td></tr>
<tr class="memdesc:a7c703e5e1a206900989d7ea9da7c6ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">the function is implemented by the <code>TYPE_INFORMATION</code> macro.  <a href="classfantom_1_1Function.html#a7c703e5e1a206900989d7ea9da7c6ba7">More...</a><br /></td></tr>
<tr class="separator:a7c703e5e1a206900989d7ea9da7c6ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747b9c01b24df5a84fc58e4cbe633b40"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1Function.html#a747b9c01b24df5a84fc58e4cbe633b40">Function</a> (const std::shared_ptr&lt; const <a class="el" href="classfantom_1_1Domain.html">Domain</a> &gt; &amp;<a class="el" href="classfantom_1_1FunctionBase.html#a7b97523d492a71a4bc5189165ec46709">domain</a>, const <a class="el" href="classfantom_1_1DomainPart.html">DomainPart</a> &amp;part, const <a class="el" href="classfantom_1_1ValueArray.html">ValueArray</a>&lt; T &gt; &amp;<a class="el" href="classfantom_1_1Function.html#ab43527b381665995f0fda1c04666e43e">values</a>, std::vector&lt; double &gt; timesteps=std::vector&lt; double &gt;{})</td></tr>
<tr class="memdesc:a747b9c01b24df5a84fc58e4cbe633b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new function on the given domain and domainpart.  <a href="classfantom_1_1Function.html#a747b9c01b24df5a84fc58e4cbe633b40">More...</a><br /></td></tr>
<tr class="separator:a747b9c01b24df5a84fc58e4cbe633b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43527b381665995f0fda1c04666e43e"><td class="memItemLeft" align="right" valign="top"><a id="ab43527b381665995f0fda1c04666e43e"></a>
const <a class="el" href="classfantom_1_1ValueArray.html">ValueArray</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1Function.html#ab43527b381665995f0fda1c04666e43e">values</a> () const</td></tr>
<tr class="memdesc:ab43527b381665995f0fda1c04666e43e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the underlying <a class="el" href="classfantom_1_1ValueArray.html" title="an array which stores data">ValueArray</a>. <br /></td></tr>
<tr class="separator:ab43527b381665995f0fda1c04666e43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac12003dea43f2858f7cb5e5084b7e9"><td class="memItemLeft" align="right" valign="top"><a id="a3ac12003dea43f2858f7cb5e5084b7e9"></a>
std::unique_ptr&lt; <a class="el" href="classfantom_1_1FunctionEvaluator.html">FunctionEvaluator</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1Function.html#a3ac12003dea43f2858f7cb5e5084b7e9">makeEvaluator</a> () const</td></tr>
<tr class="memdesc:a3ac12003dea43f2858f7cb5e5084b7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a time-interpolated evaluator for access to the function at given points in time. <br /></td></tr>
<tr class="separator:a3ac12003dea43f2858f7cb5e5084b7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b645bc2649af61fd9a64f011dba39d"><td class="memItemLeft" align="right" valign="top"><a id="a58b645bc2649af61fd9a64f011dba39d"></a>
std::unique_ptr&lt; <a class="el" href="classfantom_1_1DiscreteFunctionEvaluator.html">DiscreteFunctionEvaluator</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1Function.html#a58b645bc2649af61fd9a64f011dba39d">makeDiscreteEvaluator</a> () const</td></tr>
<tr class="memdesc:a58b645bc2649af61fd9a64f011dba39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a discrete evaluator for access to time-slices. <br /></td></tr>
<tr class="separator:a58b645bc2649af61fd9a64f011dba39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f2e545498ae756a88e90d06114607d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classfantom_1_1FunctionBase.html">FunctionBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1Function.html#aa8f2e545498ae756a88e90d06114607d">transferToDomain</a> (const std::shared_ptr&lt; const <a class="el" href="classfantom_1_1Domain.html">Domain</a> &gt; &amp;targetDomain, const <a class="el" href="classfantom_1_1DomainPart.html">DomainPart</a> &amp;targetPart=Domain::any, std::vector&lt; double &gt; timesteps=std::vector&lt; double &gt;{}) const override</td></tr>
<tr class="memdesc:aa8f2e545498ae756a88e90d06114607d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer the data to a new domain.  <a href="classfantom_1_1Function.html#aa8f2e545498ae756a88e90d06114607d">More...</a><br /></td></tr>
<tr class="separator:aa8f2e545498ae756a88e90d06114607d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e10c42dee7a5a41e1d46817c484944b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1FunctionBase.html#a8e10c42dee7a5a41e1d46817c484944b">isCompatibleTo</a> (const <a class="el" href="classfantom_1_1FunctionBase.html">FunctionBase</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a8e10c42dee7a5a41e1d46817c484944b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the other <a class="el" href="classfantom_1_1FunctionBase.html" title="Base class for discrete (sample-based) functions on Domains.">FunctionBase</a> is defined on the same <a class="el" href="classfantom_1_1Domain.html" title="Discrete domain.">Domain</a> and <a class="el" href="classfantom_1_1DomainPart.html" title="Representation of a part of a domain, for example the points of a grid, the edges of a graph,...">DomainPart</a>.  <a href="classfantom_1_1FunctionBase.html#a8e10c42dee7a5a41e1d46817c484944b">More...</a><br /></td></tr>
<tr class="separator:a8e10c42dee7a5a41e1d46817c484944b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b97523d492a71a4bc5189165ec46709"><td class="memItemLeft" align="right" valign="top"><a id="a7b97523d492a71a4bc5189165ec46709"></a>
const std::shared_ptr&lt; const <a class="el" href="classfantom_1_1Domain.html">Domain</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1FunctionBase.html#a7b97523d492a71a4bc5189165ec46709">domain</a> () const</td></tr>
<tr class="memdesc:a7b97523d492a71a4bc5189165ec46709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the domain this function is defined on. <br /></td></tr>
<tr class="separator:a7b97523d492a71a4bc5189165ec46709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b1015248b656abf1e1c27d082781a7"><td class="memItemLeft" align="right" valign="top"><a id="a47b1015248b656abf1e1c27d082781a7"></a>
const <a class="el" href="classfantom_1_1DomainPart.html">DomainPart</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1FunctionBase.html#a47b1015248b656abf1e1c27d082781a7">domainPart</a> () const</td></tr>
<tr class="memdesc:a47b1015248b656abf1e1c27d082781a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the domain part this function is defined on. <br /></td></tr>
<tr class="separator:a47b1015248b656abf1e1c27d082781a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0846fb448a2e1338fdfec3fb8569152a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefantom.html#aa6e610a8058f50d0bb5da8b05e48fc67">TimeBehavior</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1FunctionBase.html#a0846fb448a2e1338fdfec3fb8569152a">timeBehavior</a> () const</td></tr>
<tr class="memdesc:a0846fb448a2e1338fdfec3fb8569152a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time behavior of this function.  <a href="classfantom_1_1FunctionBase.html#a0846fb448a2e1338fdfec3fb8569152a">More...</a><br /></td></tr>
<tr class="separator:a0846fb448a2e1338fdfec3fb8569152a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0801edd03697ec97ffbf59ba136d10"><td class="memItemLeft" align="right" valign="top"><a id="a3b0801edd03697ec97ffbf59ba136d10"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1FunctionBase.html#a3b0801edd03697ec97ffbf59ba136d10">numTimeSteps</a> () const</td></tr>
<tr class="memdesc:a3b0801edd03697ec97ffbf59ba136d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of time steps. <br /></td></tr>
<tr class="separator:a3b0801edd03697ec97ffbf59ba136d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed263f0ce4c6db14a656f4c047781a62"><td class="memItemLeft" align="right" valign="top"><a id="aed263f0ce4c6db14a656f4c047781a62"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1FunctionBase.html#aed263f0ce4c6db14a656f4c047781a62">timeStep</a> (size_t timeStepId) const</td></tr>
<tr class="memdesc:aed263f0ce4c6db14a656f4c047781a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time of the i-th time step. <br /></td></tr>
<tr class="separator:aed263f0ce4c6db14a656f4c047781a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ca5b84fc7ab9e5394a75a176c323b8"><td class="memItemLeft" align="right" valign="top"><a id="a55ca5b84fc7ab9e5394a75a176c323b8"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1FunctionBase.html#a55ca5b84fc7ab9e5394a75a176c323b8">timeSteps</a> () const</td></tr>
<tr class="memdesc:a55ca5b84fc7ab9e5394a75a176c323b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of all time steps. <br /></td></tr>
<tr class="separator:a55ca5b84fc7ab9e5394a75a176c323b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e935fb9d68cb4391098f0fb04757b5d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1FunctionBase.html#a8e935fb9d68cb4391098f0fb04757b5d">timeRange</a> () const</td></tr>
<tr class="memdesc:a8e935fb9d68cb4391098f0fb04757b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair containing the lowest and highest time in the data.  <a href="classfantom_1_1FunctionBase.html#a8e935fb9d68cb4391098f0fb04757b5d">More...</a><br /></td></tr>
<tr class="separator:a8e935fb9d68cb4391098f0fb04757b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a29fabfbf5e26da8047d8a20329530e"><td class="memItemLeft" align="right" valign="top"><a id="a6a29fabfbf5e26da8047d8a20329530e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1FunctionBase.html#a6a29fabfbf5e26da8047d8a20329530e">numValues</a> () const</td></tr>
<tr class="memdesc:a6a29fabfbf5e26da8047d8a20329530e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of values in each time step. <br /></td></tr>
<tr class="separator:a6a29fabfbf5e26da8047d8a20329530e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d239b11ae818b00d38186fa000f292f"><td class="memItemLeft" align="right" valign="top"><a id="a3d239b11ae818b00d38186fa000f292f"></a>
std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1FunctionBase.html#a3d239b11ae818b00d38186fa000f292f">getInfoStrings</a> () const override</td></tr>
<tr class="memdesc:a3d239b11ae818b00d38186fa000f292f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an info string containing the size and the precision of the function. <br /></td></tr>
<tr class="separator:a3d239b11ae818b00d38186fa000f292f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e511df251bdb23b184c6632b424d7c2"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a6e511df251bdb23b184c6632b424d7c2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfantom_1_1RTTI.html#a6e511df251bdb23b184c6632b424d7c2">isA</a> () const</td></tr>
<tr class="memdesc:a6e511df251bdb23b184c6632b424d7c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the object is a child of <code>Type</code> or a <code>Type</code> itself  <a href="classfantom_1_1RTTI.html#a6e511df251bdb23b184c6632b424d7c2">More...</a><br /></td></tr>
<tr class="separator:a6e511df251bdb23b184c6632b424d7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad200983f4fbf3a4fd7300442b85cc978"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1RTTI.html#ad200983f4fbf3a4fd7300442b85cc978">isA</a> (const TypeId &amp;type) const</td></tr>
<tr class="memdesc:ad200983f4fbf3a4fd7300442b85cc978"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the object is a child of <code>type</code> or a <code>type</code> itself.  <a href="classfantom_1_1RTTI.html#ad200983f4fbf3a4fd7300442b85cc978">More...</a><br /></td></tr>
<tr class="separator:ad200983f4fbf3a4fd7300442b85cc978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca71e2cbcda6021eb6a924ca9e3eb078"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1RTTI.html#aca71e2cbcda6021eb6a924ca9e3eb078">typeName</a> () const</td></tr>
<tr class="memdesc:aca71e2cbcda6021eb6a924ca9e3eb078"><td class="mdescLeft">&#160;</td><td class="mdescRight">the function is implemented by the <code>TYPE_INFORMATION</code> macro.  <a href="classfantom_1_1RTTI.html#aca71e2cbcda6021eb6a924ca9e3eb078">More...</a><br /></td></tr>
<tr class="separator:aca71e2cbcda6021eb6a924ca9e3eb078"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a32b82014cca8a497f0c6818793014a2d"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a32b82014cca8a497f0c6818793014a2d"><td class="memTemplItemLeft" align="right" valign="top">static const TypeId &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfantom_1_1RTTI.html#a32b82014cca8a497f0c6818793014a2d">typeId</a> ()</td></tr>
<tr class="memdesc:a32b82014cca8a497f0c6818793014a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the function Type::classTypeId is implemented by the <code>TYPE_INFORMATION</code> macro.  <a href="classfantom_1_1RTTI.html#a32b82014cca8a497f0c6818793014a2d">More...</a><br /></td></tr>
<tr class="separator:a32b82014cca8a497f0c6818793014a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fd8078dff62d7f53cd8df932be248b"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ac5fd8078dff62d7f53cd8df932be248b"><td class="memTemplItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfantom_1_1RTTI.html#ac5fd8078dff62d7f53cd8df932be248b">typeName</a> ()</td></tr>
<tr class="memdesc:ac5fd8078dff62d7f53cd8df932be248b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the string representation of the type name the function Type::classTypeName is implemented by the <code>TYPE_INFORMATION</code> macro.  <a href="classfantom_1_1RTTI.html#ac5fd8078dff62d7f53cd8df932be248b">More...</a><br /></td></tr>
<tr class="separator:ac5fd8078dff62d7f53cd8df932be248b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106fac2cd20e7ed59e57783bebedc80a"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1RTTI.html#a106fac2cd20e7ed59e57783bebedc80a">typeName</a> (const TypeId &amp;<a class="el" href="classfantom_1_1Function.html#a7c703e5e1a206900989d7ea9da7c6ba7">typeId</a>)</td></tr>
<tr class="memdesc:a106fac2cd20e7ed59e57783bebedc80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the string representation of the type with the <code>TypeId</code> <em>typeId</em>. The function is implemented by the /c TYPE_INFORMATION macro.  <a href="classfantom_1_1RTTI.html#a106fac2cd20e7ed59e57783bebedc80a">More...</a><br /></td></tr>
<tr class="separator:a106fac2cd20e7ed59e57783bebedc80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a6029b1ac6c51fd5666aea78a973bfcde"><td class="memItemLeft" align="right" valign="top"><a id="a6029b1ac6c51fd5666aea78a973bfcde"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfantom_1_1DataObject.html#a6029b1ac6c51fd5666aea78a973bfcde">addPrefixedInfoStrings</a> (std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;targetInfoStrings, const std::string &amp;prefix, std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; stringsToBeAppended)</td></tr>
<tr class="memdesc:a6029b1ac6c51fd5666aea78a973bfcde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends <code>stringsToBeAppended</code> to <code>targetInfoStrings</code> and thereby prepends <code>prefix</code> to every key of <code>stringsToBeAppended</code>. <br /></td></tr>
<tr class="separator:a6029b1ac6c51fd5666aea78a973bfcde"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class fantom::Function&lt; T &gt;</h3>

<p>Representation of data values on a discrete domain. </p>
<p>The <em><a class="el" href="classfantom_1_1Domain.html" title="Discrete domain.">Domain</a></em> can be any discrete structure, like <em><a class="el" href="classfantom_1_1Grid.html" title="Representation of grids.">Grid</a></em>, <em><a class="el" href="classfantom_1_1Graph.html" title="Graph domain.">Graph</a></em>, <em><a class="el" href="classfantom_1_1PointSet.html" title="representation of a discrete set of points">PointSet</a></em>, <em><a class="el" href="classfantom_1_1Table.html" title="Representation of a table.">Table</a></em>, etc. Function&lt; T &gt; associates some values (represented by a <code><a class="el" href="classfantom_1_1ValueArray.html" title="an array which stores data">ValueArray</a></code>) with such a discrete structure. All meta data that characterizes this association (time behavior, timesteps, part of the domain that the data belongs to) is stored in this object. Specific accessor objects for easy evaluation of the function at specific points in time are provided through the <code><a class="el" href="classfantom_1_1Function.html#a3ac12003dea43f2858f7cb5e5084b7e9" title="Create a time-interpolated evaluator for access to the function at given points in time.">makeEvaluator()</a></code> and <code><a class="el" href="classfantom_1_1Function.html#a58b645bc2649af61fd9a64f011dba39d" title="Create a discrete evaluator for access to time-slices.">makeDiscreteEvaluator()</a></code> functions.</p>
<p>The goal of this design is to have an easy interface to the data that is independent from the specific domain the data is registered on (regarding the C++ type). This makes it easy to write common and general algorithms that only process data without needing to know the domain type. All domain-related data is encoded in the meta-data and is easily copyable. This allows for truly domain-agnostic algorithms without the disadvantage that the domain-related data would be pruned. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a747b9c01b24df5a84fc58e4cbe633b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747b9c01b24df5a84fc58e4cbe633b40">&#9670;&nbsp;</a></span>Function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfantom_1_1Function.html">fantom::Function</a>&lt; T &gt;::<a class="el" href="classfantom_1_1Function.html">Function</a> </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classfantom_1_1Domain.html">Domain</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfantom_1_1DomainPart.html">DomainPart</a> &amp;&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfantom_1_1ValueArray.html">ValueArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>timesteps</em> = <code>std::vector&lt;&#160;double&#160;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new function on the given domain and domainpart. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The domain must not be nullptr. </dd>
<dd>
domain.domainPartSize( part ) * timesteps.size() == values.size() </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7c703e5e1a206900989d7ea9da7c6ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c703e5e1a206900989d7ea9da7c6ba7">&#9670;&nbsp;</a></span>typeId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const fantom::RTTI::TypeId&amp; <a class="el" href="classfantom_1_1Function.html">fantom::Function</a>&lt; T &gt;::typeId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the function is implemented by the <code>TYPE_INFORMATION</code> macro. </p>
<dl class="section return"><dt>Returns</dt><dd>the <code>TypeId</code> of this class </dd></dl>

<p>Reimplemented from <a class="el" href="classfantom_1_1FunctionBase.html#a7418c5162ce7d6d1b318d28147e5db92">fantom::FunctionBase</a>.</p>

</div>
</div>
<a id="aa8f2e545498ae756a88e90d06114607d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f2e545498ae756a88e90d06114607d">&#9670;&nbsp;</a></span>transferToDomain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classfantom_1_1FunctionBase.html">FunctionBase</a> &gt; <a class="el" href="classfantom_1_1Function.html">fantom::Function</a>&lt; T &gt;::transferToDomain </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classfantom_1_1Domain.html">Domain</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>targetDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfantom_1_1DomainPart.html">DomainPart</a> &amp;&#160;</td>
          <td class="paramname"><em>targetPart</em> = <code>Domain::any</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>timesteps</em> = <code>std::vector&lt;&#160;double&#160;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer the data to a new domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetDomain</td><td>the domain that the data should be transfered to </td></tr>
    <tr><td class="paramname">targetPart</td><td>the part that the data should be transfered to. Use Domain::any to let the function autoselect. </td></tr>
    <tr><td class="paramname">timesteps</td><td>the time steps for the target domain. Leave empty to let the function autoselect.</td></tr>
  </table>
  </dd>
</dl>
<p>See <em>transferData</em> for details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>targetDomain != nullptr</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfantom_1_1logic__error.html" title="A fantom-created equivalent to std::logic_error.">fantom::logic_error</a></td><td>on invalid inputs </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classfantom_1_1FunctionBase.html#ae6eacd0c49ea6205a9d14a90ec5f81f5">fantom::FunctionBase</a>.</p>

</div>
</div>
<a id="a32b82014cca8a497f0c6818793014a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b82014cca8a497f0c6818793014a2d">&#9670;&nbsp;</a></span>typeId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const TypeId&amp; fantom::RTTI::typeId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the function Type::classTypeId is implemented by the <code>TYPE_INFORMATION</code> macro. </p>
<dl class="section return"><dt>Returns</dt><dd>the <code>TypeId</code> of type <code>Type</code> </dd></dl>

</div>
</div>
<a id="a8e10c42dee7a5a41e1d46817c484944b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e10c42dee7a5a41e1d46817c484944b">&#9670;&nbsp;</a></span>isCompatibleTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fantom::FunctionBase::isCompatibleTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfantom_1_1FunctionBase.html">FunctionBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the other <a class="el" href="classfantom_1_1FunctionBase.html" title="Base class for discrete (sample-based) functions on Domains.">FunctionBase</a> is defined on the same <a class="el" href="classfantom_1_1Domain.html" title="Discrete domain.">Domain</a> and <a class="el" href="classfantom_1_1DomainPart.html" title="Representation of a part of a domain, for example the points of a grid, the edges of a graph,...">DomainPart</a>. </p>
<p>In that case, the two Functions are compatible and their values can be used together in computations. Note, that the Functions can still differ in their number of timesteps. </p>

</div>
</div>
<a id="a0846fb448a2e1338fdfec3fb8569152a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0846fb448a2e1338fdfec3fb8569152a">&#9670;&nbsp;</a></span>timeBehavior()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefantom.html#aa6e610a8058f50d0bb5da8b05e48fc67">TimeBehavior</a> fantom::FunctionBase::timeBehavior </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the time behavior of this function. </p>
<p>See TimeBehavior for further information. </p>

</div>
</div>
<a id="a8e935fb9d68cb4391098f0fb04757b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e935fb9d68cb4391098f0fb04757b5d">&#9670;&nbsp;</a></span>timeRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, double &gt; fantom::FunctionBase::timeRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pair containing the lowest and highest time in the data. </p>
<p>In the steady case the lower and upper bound are returned.</p>
<p>In the unsteady case, the first and the last time step are returned. </p>

</div>
</div>
<a id="a6e511df251bdb23b184c6632b424d7c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e511df251bdb23b184c6632b424d7c2">&#9670;&nbsp;</a></span>isA() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fantom::RTTI::isA </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if the object is a child of <code>Type</code> or a <code>Type</code> itself </p>
<dl class="section return"><dt>Returns</dt><dd>true if the object is a child of <code>Type</code> or a <code>Type</code> itself </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfantom_1_1RTTI.html#ad200983f4fbf3a4fd7300442b85cc978" title="returns true if the object is a child of type or a type itself.">isA( const TypeId&amp; type ) const</a> </dd></dl>

</div>
</div>
<a id="ad200983f4fbf3a4fd7300442b85cc978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad200983f4fbf3a4fd7300442b85cc978">&#9670;&nbsp;</a></span>isA() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fantom::RTTI::isA </td>
          <td>(</td>
          <td class="paramtype">const TypeId &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if the object is a child of <code>type</code> or a <code>type</code> itself. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the object is a child of type or a type itself </dd></dl>

</div>
</div>
<a id="aca71e2cbcda6021eb6a924ca9e3eb078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca71e2cbcda6021eb6a924ca9e3eb078">&#9670;&nbsp;</a></span>typeName() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; fantom::RTTI::typeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the function is implemented by the <code>TYPE_INFORMATION</code> macro. </p>
<dl class="section return"><dt>Returns</dt><dd>the string representation of the type name </dd></dl>

</div>
</div>
<a id="ac5fd8078dff62d7f53cd8df932be248b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fd8078dff62d7f53cd8df932be248b">&#9670;&nbsp;</a></span>typeName() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; fantom::RTTI::typeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the string representation of the type name the function Type::classTypeName is implemented by the <code>TYPE_INFORMATION</code> macro. </p>
<dl class="section return"><dt>Returns</dt><dd>the string representation of the type name </dd></dl>

</div>
</div>
<a id="a106fac2cd20e7ed59e57783bebedc80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106fac2cd20e7ed59e57783bebedc80a">&#9670;&nbsp;</a></span>typeName() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; fantom::RTTI::typeName </td>
          <td>(</td>
          <td class="paramtype">const TypeId &amp;&#160;</td>
          <td class="paramname"><em>typeId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the string representation of the type with the <code>TypeId</code> <em>typeId</em>. The function is implemented by the /c TYPE_INFORMATION macro. </p>
<dl class="section return"><dt>Returns</dt><dd>the string representation of the type with the <code>TypeId</code> <em>typeId</em> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
